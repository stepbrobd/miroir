open Ppxlib
open Ppxlib.Ast_builder.Default

(* e.g. type foo = { bar : (string * string) list [@toml.assoc_table] } *)
let attr_name = "toml.assoc_table"

(* dependent on the rewrites generated by [@@deriving toml], must have both *)
(* e.g. type config = { ... } [@@deriving toml, toml_assoc_table] *)
let derv_name = "toml_assoc_table"

(* check if record field ast node have [@toml.assoc_table] attribute *)
let derivable ld =
  List.exists (fun attr -> attr.attr_name.txt = attr_name) ld.pld_attributes
;;

(* shadow the <name>_of_toml function generated by ppx_deriving_toml *)
(* e.g. type config = { ... env : (string * string) list [@toml.assoc_table]; ... } *)
(* => let config_of_toml = fun toml -> ... (shadows original function) *)
let derive ~loc type_name fields =
  let of_toml_name = type_name ^ "_of_toml" in
  let assoc_fields = List.filter derivable fields in
  if assoc_fields = []
  then []
  else (
    (* take record field ast node in assoc list type like (string * platform) list *)
    (* return deserilization function in string "platform_of_toml" *)
    (* require string type for key and value is a named type *)
    let deserializer_name_for field =
      (* let () = print_endline field.pld_name.txt in *)
      match field.pld_type.ptyp_desc with
      | Ptyp_constr ({ txt = Lident "list"; _ }, [ tuple_type ]) ->
        (match tuple_type.ptyp_desc with
         | Ptyp_tuple [ key_type; value_type ] ->
           (* string only key type *)
           (match key_type.ptyp_desc with
            | Ptyp_constr ({ txt = Lident "string"; _ }, []) -> ()
            | _ ->
              Location.raise_errorf
                ~loc:field.pld_loc
                "[@toml.assoc_table] requires (string * 'a) list, got (%a * 'a) list"
                Pprintast.core_type
                key_type);
           (match value_type.ptyp_desc with
            | Ptyp_constr ({ txt = Lident vt; _ }, []) -> vt ^ "_of_toml"
            | _ ->
              Location.raise_errorf
                ~loc:field.pld_loc
                "[@toml.assoc_table] value type must be a named type, not %a"
                Pprintast.core_type
                value_type)
         | _ ->
           Location.raise_errorf
             ~loc:field.pld_loc
             "[@toml.assoc_table] requires (string * 'a) list, got %a"
             Pprintast.core_type
             field.pld_type)
      | _ ->
        Location.raise_errorf
          ~loc:field.pld_loc
          "[@toml.assoc_table] can only be applied to (string * 'a) list fields"
    in
    let field_names = List.map (fun ld -> ld.pld_name.txt) assoc_fields in
    (* need this check or will get warning *)
    (* (warning 23 [useless-record-with]): all the fields are explicitly listed in this record: the 'with' clause is useless.*)
    (* (warning 26 [unused-var]): unused variable base. *)
    let has_non_assoc_fields = List.length assoc_fields < List.length fields in
    (* build record update expression: e.g. { env = env; platform = platform; base } *)
    (* where base contains all non assoc list fields parsed by original function *)
    let record_update =
      pexp_record
        ~loc
        (List.map
           (fun ld -> { loc; txt = Lident ld.pld_name.txt }, evar ~loc ld.pld_name.txt)
           assoc_fields)
        (* see has_non_assoc_fields def *)
        (if has_non_assoc_fields then Some (evar ~loc "base") else None)
    in
    (* field parsing logic: let env = ... in let platform = ... in { ... } *)
    (* each assoc field is extracted from toml table and converted to assoc list *)
    let body =
      List.fold_right
        (fun ld acc ->
           let field_name = ld.pld_name.txt in
           let deserializer = deserializer_name_for ld in
           [%expr
             (* runtime function defined below *)
             let [%p pvar ~loc field_name] =
               match get_field_opt [%e estring ~loc field_name] items with
               | Some t -> table_to_assoc_list [%e evar ~loc deserializer] t
               | None -> []
             in
             [%e acc]])
        assoc_fields
        record_update
    in
    (* - define helper functions inline *)
    (* - extract assoc_table fields from toml *)
    (* - parse remaining fields with original function *)
    (* - profit *)
    let wrapper =
      (* runtime helpers *)
      [%expr
        (* table_to_assoc_list (of_toml_fn : deserializer) -> (toml : TomlTable) -> (string * 'a) list *)
        let table_to_assoc_list of_toml_fn toml =
          match toml with
          | Otoml.TomlTable items | Otoml.TomlInlineTable items ->
            List.map (fun (k, v) -> k, of_toml_fn v) items
          | _ ->
            Ppx_deriving_toml_runtime.of_toml_error
              "[@toml.assoc_table] expected a TOML table"
        in
        (* get_field_opt (key : string) -> (items : (string * toml) list) -> toml option *)
        let get_field_opt key items =
          try Some (List.assoc key items) with
          | Not_found -> None
        in
        (* weird shit *)
        match toml with
        | Otoml.TomlTable items ->
          [%e
            (* see has_non_assoc_fields def *)
            if has_non_assoc_fields
            then
              [%expr
                (* replace assoc fields with empty arrays so original parser dont error *)
                let items_with_empty_arrays =
                  List.fold_left
                    (fun acc field ->
                       (field, Otoml.TomlArray []) :: List.remove_assoc field acc)
                    items
                    [%e elist ~loc (List.map (estring ~loc) field_names)]
                in
                (* parse non assoc fields with ppx_deriving_toml generated function *)
                (* calls <type>_of_toml before shadowing it *)
                let base =
                  [%e evar ~loc of_toml_name] (Otoml.TomlTable items_with_empty_arrays)
                in
                (* parse assoc_table fields and update record *)
                [%e body]]
            else body]
        | _ ->
          Ppx_deriving_toml_runtime.of_toml_error
            [%e estring ~loc ("expected " ^ type_name ^ " to be a table")]]
    in
    (* shadow ppx_deriving_toml generated functions *)
    [ [%stri let [%p pvar ~loc of_toml_name] = fun toml -> [%e wrapper]] ])
;;

let () =
  Deriving.add
    derv_name
    ~str_type_decl:
      (Deriving.Generator.V2.make_noarg (fun ~ctxt (_, decls) ->
         let loc = Expansion_context.Deriver.derived_item_loc ctxt in
         List.concat_map
           (fun decl ->
              match decl.ptype_kind with
              | Ptype_record fields -> derive ~loc decl.ptype_name.txt fields
              | _ -> [])
           decls))
  |> ignore
;;
